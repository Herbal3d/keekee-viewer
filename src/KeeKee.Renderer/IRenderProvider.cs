// Copyright 2025 Robert Adams
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
// using System.Drawing;
using System.Text;
using KeeKee.World;
using OMV = OpenMetaverse;

namespace KeeKee.Renderer {
    /// <summary>
    /// The origional Mogre renderer design did the mesh generation before creating
    /// the scene node. Scene node creation has to happen between frames because
    /// you get crashes if you didn't with the scene graph while it's being rendered.
    /// So, a call is made to generate all the things needed for the scene node
    /// and these are returned in a RenderableInfo. Between frames, the scene node
    /// is created and it is decorated with all the information from RenderableInfo.
    /// For Mogre, 'basicObject' was usually a Mogre::MovableObject.
    /// 
    /// The Ogre renderer design has the mesh generated by demand after the
    /// scene node is created. In this post generation model, RenderableInfo
    /// is not used or is just passed for compatability.
    /// </summary>
    public class RenderableInfo {
        public Object basicObject;
        // public uint parentID;
        public IEntity parentEntity;
        public const ulong NO_HASH_SHARE = 0;
        public ulong shapeHash;
        public OMV.Vector3 position;
        public OMV.Quaternion rotation;
        public OMV.Vector3 scale;
        public Object RegionRoot;
        public RenderableInfo() {
            basicObject = null; RegionRoot = null;
            // parentID = 0;
            parentEntity = null;
            position = OMV.Vector3.Zero;
            rotation = new OMV.Quaternion(0f, 0f, 0f, 0f);
            scale = new OMV.Vector3(1f, 1f, 1f);
        }
    }

    public enum InputModeCode {
        ModeMainKeys,   // focus on main display, input is keystrokes
        MainKeysMouse,  // focus on main display, input is keystrokes and mouse
        MainSelect,     // focus on main display, select objects
        OverlayNext,    // focus on next overlay
        OverlayLast,    // focus on next overlay
    };

    public delegate void RendererBeforeFrameCallback();

    public interface IRenderProvider {
        IUserInterfaceProvider UserInterface { get; }

        // entry for main thread for rendering. Return false if you don't need it.
        bool RendererThread();
        // entry for rendering one frame. An alternate to the above thread method
        bool RenderOneFrame(bool pump, int len);

        //=================================================================
        // Set the entity to be rendered
        void Render(IEntity ent);
        void RenderUpdate(IEntity ent, UpdateCodes what);
        void UnRender(IEntity ent);

        // tell the renderer about the camera position
        void UpdateCamera(CameraControl cam);
        void UpdateEnvironmentalLights(IEntity pSun, IEntity pMoon);
        // TODO: ambient setting

        // Given the current mouse position, return a point in the world
        OMV.Vector3d SelectPoint();

        // called when a new region is found, decorates the region context with
        // rendering specific information for placing in  the view
        void MapRegionIntoView(IRegionContext rcontext);
        // Set a region as the high resolution focus region
        void SetFocusRegion(IRegionContext rcontext);

        // something about the terrain has changed, do some updating
        void UpdateTerrain(IRegionContext wcontext);
    }
}
